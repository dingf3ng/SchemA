// Advanced test: Records with non-string keys
// This demonstrates that records can have polymorphic key types

print("=== Test: Graph Records with Different Node Types ===\n")

// Test 1: Integer nodes
print("1. Graph with Integer nodes:")
let intGraph = Graph(false)
intGraph.addVertex(1)
intGraph.addVertex(2)
intGraph.addVertex(3)
intGraph.addEdge(1, 2, 10)
intGraph.addEdge(2, 3, 20)

let intEdges = intGraph.getEdges()
// Type: Array<{ from: int, to: int, weight: int }>
// This is a record with string keys ("from", "to", "weight")
// but the VALUES are polymorphic (from/to are int, weight is int)
print("Integer graph edges:")
for edge in intEdges {
  print("  from:", edge["from"], "to:", edge["to"], "weight:", edge["weight"])
}

// Test 2: String nodes
print("\n2. Graph with String nodes:")
let strGraph = Graph(true)
strGraph.addVertex("Alice")
strGraph.addVertex("Bob")
strGraph.addVertex("Carol")
strGraph.addEdge("Alice", "Bob", 5)
strGraph.addEdge("Bob", "Carol", 8)

let strEdges = strGraph.getEdges()
// Type: Array<{ from: string, to: string, weight: int }>
// Same record structure, but from/to are now strings
print("String graph edges:")
for edge in strEdges {
  print("  from:", edge["from"], "to:", edge["to"], "weight:", edge["weight"])
}

print("\n=== Demonstrating Record Key Type Polymorphism ===\n")

// In the current implementation, records use string keys for field names
// but the field VALUES can be any type, making records value-polymorphic

// Example: A graph edge record
print("3. Record field value polymorphism:")
let graph3 = Graph(false)
graph3.addVertex(100)
graph3.addVertex(200)
graph3.addEdge(100, 200, 42)

let edges3 = graph3.getNeighbors(100)
print("Edge record structure:")
for edge in edges3 {
  // This record has:
  //   - key "to" -> value type: int
  //   - key "weight" -> value type: int
  // The keys are strings, but values are polymorphic
  print("  Field 'to' (int):", edge["to"])
  print("  Field 'weight' (int):", edge["weight"])
}

print("\n=== Tuple Type Polymorphism ===\n")

// Tuples have positional polymorphism - each position can be a different type
print("4. Map entries as polymorphic tuples:")

let map1 = Map()
map1.set("x", 10)
map1.set("y", 20)

let entries1 = map1.entries()
// Type: Array<(string, int)>
// Each tuple is (key: string, value: int)
print("String->Int tuples:")
for entry in entries1 {
  print("  ", entry)
}

let map2 = Map()
map2.set(1, "one")
map2.set(2, "two")

let entries2 = map2.entries()
// Type: Array<(int, string)>
// Each tuple is (key: int, value: string)
print("\nInt->String tuples:")
for entry in entries2 {
  print("  ", entry)
}

print("\n=== Mixed Type Records ===\n")

// A record can have fields of different types
print("5. Heterogeneous record (edge with different field types):")
let graph5 = Graph(true)
graph5.addVertex("node1")
graph5.addVertex("node2")
graph5.addEdge("node1", "node2", 99)

let edges5 = graph5.getEdges()
// Type: Array<{ from: string, to: string, weight: int }>
// This record has TWO different value types:
//   - "from" and "to" are strings
//   - "weight" is int
print("Heterogeneous record:")
for edge in edges5 {
  print("  from (string):", edge["from"])
  print("  to (string):", edge["to"])
  print("  weight (int):", edge["weight"])
}

print("\n=== Summary ===")
print("✓ Records support polymorphic field values")
print("✓ Record field names are strings, but values can be any type")
print("✓ Tuples support positional type polymorphism")
print("✓ Both structures enable precise type checking")
print("✓ Dynamic types handle dynamic field access on records")
