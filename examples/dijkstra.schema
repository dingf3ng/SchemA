// Dijkstra's shortest path algorithm

do dijkstra(graph, start) -> Map<int, int> {
  let dist = Map(),
      visited = Set(),
      pq = MinHeapMap(),
      n = graph.size()
  
  for i in ..n {
    dist.set(i, inf)
  }
  dist.set(start, 0)
  pq.push(start, 0)

  until pq.size() == 0 {
    let current = pq.pop()
    if visited.has(current) {
      return dist
    }
    visited.add(current)
    let adjs = graph.getNeighbors(current)

    for adj in adjs {
      let neighbor = adj["to"],
          weight = adj["weight"]
      let newDist = dist.get(current) + weight
      if newDist < dist.get(neighbor) {
        dist.set(neighbor, newDist)
        pq.push(neighbor, newDist)
      }
    }
  }

  return dist
}

// Create a weighted graph
let g = Graph(true)

// Add vertices
g.addVertex(0)
g.addVertex(1)
g.addVertex(2)
g.addVertex(3)
g.addVertex(4)
g.addVertex(5)
g.addVertex(6)

// Add edges with weights
g.addEdge(0, 1, 2)
g.addEdge(0, 3, 5)
g.addEdge(0, 5, 3)
g.addEdge(1, 2, 7)
g.addEdge(1, 4, 1)
g.addEdge(1, 5, 4)
g.addEdge(2, 4, 3)
g.addEdge(2, 6, 4)
g.addEdge(3, 4, 1)
g.addEdge(3, 6, 1)
g.addEdge(4, 6, 3)


print("Running Dijkstra from node 0:")
let distances = dijkstra(g, 0)

for i in ..g.getVertices().length() {
  print("Distance to node", i, ":", distances.get(i))
}
