// Bellman-Ford algorithm for shortest paths (handles negative weights)

do bellmanFord(graph, start) {
  let dist = Map(),
      edges = graph.getEdges(),
      n = graph.size()
  for i in ..n {
    dist.set(i, int_inf)
  }

  dist.set(start, 0)

  // Relax edges n-1 times
  for _  in ..n {
    for edge in edges {
      let u = edge["from"],
          v = edge["to"],
          w = edge["weight"]

      if dist.get(u) != int_inf {
        let newDist = dist.get(u) + w
        if newDist < dist.get(v) {
          dist.set(v, newDist)
        }
      }
    }
  }

  // Check for negative cycles
  for edge in edges {
    let u = edge["from"],
        v = edge["to"],
        w = edge["weight"]
    if dist.get(u) != int_inf {
      let newDist = dist.get(u) + w
      if newDist < dist.get(v) {
        print("Negative cycle detected!")
        return dist
      }
    }
  }

  return dist
}

// Create a weighted graph
let g = Graph(true)

// Add vertices
g.addVertex(0)
g.addVertex(1)
g.addVertex(2)
g.addVertex(3)
g.addVertex(4)
g.addVertex(5)
g.addVertex(6)

// Add edges with weights
g.addEdge(0, 1, 2)
g.addEdge(0, 3, 5)
g.addEdge(0, 5, 3)
g.addEdge(1, 2, 7)
g.addEdge(1, 4, 1)
g.addEdge(1, 5, 4)
g.addEdge(2, 4, 3)
g.addEdge(2, 6, 4)
g.addEdge(3, 4, 1)
g.addEdge(3, 6, 1)
g.addEdge(4, 6, 3)

print("Running Bellman-Ford from node 0:")
let distances = bellmanFord(g, 0)

for i in ..g.size() {
  print("Distance to node", i, ":", distances.get(i))
}
