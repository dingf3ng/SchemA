// Test suite for polymorphic record and tuple types

print("=== Test 1: Record with String Keys ===")
let stringGraph = Graph(false)
stringGraph.addVertex("A")
stringGraph.addVertex("B")
stringGraph.addEdge("A", "B", 10)

let stringNeighbors = stringGraph.getNeighbors("A")
for edge in stringNeighbors {
  // edge is { to: string, weight: int }
  print("String edge: to =", edge["to"], ", weight =", edge["weight"])
}

print("\n=== Test 2: Record with Int Keys ===")
let intGraph = Graph(true)
intGraph.addVertex(100)
intGraph.addVertex(200)
intGraph.addEdge(100, 200, 50)

let intNeighbors = intGraph.getNeighbors(100)
for edge in intNeighbors {
  // edge is { to: int, weight: int }
  print("Int edge: to =", edge["to"], ", weight =", edge["weight"])
}

print("\n=== Test 3: Complex Graph Records ===")
let complexGraph = Graph(false)
complexGraph.addVertex(1)
complexGraph.addVertex(2)
complexGraph.addVertex(3)
complexGraph.addEdge(1, 2, 15)
complexGraph.addEdge(2, 3, 25)
complexGraph.addEdge(1, 3, 35)

let allEdges = complexGraph.getEdges()
// allEdges is Array<{ from: int, to: int, weight: int }>
print("All edges (record with 3 fields):")
for edge in allEdges {
  print("  from:", edge["from"], ", to:", edge["to"], ", weight:", edge["weight"])
}

print("\n=== Test 4: Map Tuples with Different Types ===")

// String -> Int map
let stringIntMap = Map()
stringIntMap.set("one", 1)
stringIntMap.set("two", 2)
stringIntMap.set("three", 3)

print("String->Int Map entries (tuples):")
let stringIntEntries = stringIntMap.entries()
// stringIntEntries is Array<(string, int)>
for entry in stringIntEntries {
  print("  ", entry)
}

// Int -> String map
let intStringMap = Map()
intStringMap.set(10, "ten")
intStringMap.set(20, "twenty")
intStringMap.set(30, "thirty")

print("\nInt->String Map entries (tuples):")
let intStringEntries = intStringMap.entries()
// intStringEntries is Array<(int, string)>
for entry in intStringEntries {
  print("  ", entry)
}

// String -> String map
let stringStringMap = Map()
stringStringMap.set("hello", "world")
stringStringMap.set("foo", "bar")

print("\nString->String Map entries (tuples):")
let stringStringEntries = stringStringMap.entries()
// stringStringEntries is Array<(string, string)>
for entry in stringStringEntries {
  print("  ", entry)
}

print("\n=== Test 5: Nested Structures ===")

// Array of records from graph
let graph5 = Graph(false)
graph5.addVertex(10)
graph5.addVertex(20)
graph5.addVertex(30)
graph5.addEdge(10, 20, 5)
graph5.addEdge(20, 30, 15)

let vertices5 = graph5.getVertices()
print("Processing each vertex's neighbors:")
for v in vertices5 {
  let neighbors5 = graph5.getNeighbors(v)
  print("Vertex", v, "has", neighbors5.length(), "neighbors")
  for edge in neighbors5 {
    print("  -> neighbor", edge["to"], "with weight", edge["weight"])
  }
}

print("\n=== Test 6: Type Safety with Keys ===")

// Map with int keys
let intKeyMap = Map()
intKeyMap.set(1, "first")
intKeyMap.set(2, "second")

print("Int-keyed map keys:", intKeyMap.keys())
print("Int-keyed map values:", intKeyMap.values())

// Map with string keys
let stringKeyMap = Map()
stringKeyMap.set("x", 100)
stringKeyMap.set("y", 200)

print("String-keyed map keys:", stringKeyMap.keys())
print("String-keyed map values:", stringKeyMap.values())

print("\n=== Test 7: Types from Dynamic Record Access ===")

// When a record has fields of different types and we access dynamically,
// the result should be a dynamic type
let mixedGraph = Graph(false)
mixedGraph.addVertex(1)
mixedGraph.addVertex(2)
mixedGraph.addEdge(1, 2, 99)

let mixedEdge = mixedGraph.getNeighbors(1)
// Each edge in mixedEdge has fields: to (int) and weight (int)
// In this case both fields are the same type, but the type system
// knows the structure

print("Mixed graph edge fields:")
for e in mixedEdge {
  // Accessing with literal strings gives specific types
  let toField = e["to"]      // Type: int
  let weightField = e["weight"]  // Type: int
  print("  to:", toField, ", weight:", weightField)
}

print("\n=== All polymorphic type tests completed! ===")
